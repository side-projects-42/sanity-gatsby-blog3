var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __assign = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};
__markAsModule(exports);
__export(exports, {
  color: () => color
});
var import_color = __toModule(require("@sanity/color"));
var import_color_fns = __toModule(require("../lib/color-fns"));
var import_theme = __toModule(require("../lib/theme"));
var import_helpers = __toModule(require("./helpers"));
const tones = {
  default: import_color.hues.gray,
  primary: import_color.hues.blue,
  positive: import_color.hues.green,
  caution: import_color.hues.yellow,
  critical: import_color.hues.red
};
const color = (0, import_theme.createColorTheme)({
  base: ({dark, name}) => {
    if (name === "default") {
      return {
        fg: dark ? import_color.white.hex : import_color.black.hex,
        bg: dark ? import_color.black.hex : import_color.white.hex,
        border: import_color.hues.gray[dark ? 900 : 200].hex,
        focusRing: import_color.hues.blue[500].hex,
        shadow: {
          outline: (0, import_color_fns.rgba)(import_color.hues.gray[500].hex, dark ? 0.2 : 0.4),
          umbra: (0, import_color_fns.rgba)(dark ? import_color.black.hex : import_color.hues.gray[500].hex, 0.2),
          penumbra: (0, import_color_fns.rgba)(dark ? import_color.black.hex : import_color.hues.gray[500].hex, 0.14),
          ambient: (0, import_color_fns.rgba)(dark ? import_color.black.hex : import_color.hues.gray[500].hex, 0.12)
        }
      };
    }
    if (name === "transparent") {
      const tints2 = tones.default;
      return {
        fg: tints2[dark ? 100 : 900].hex,
        bg: tints2[dark ? 950 : 50].hex,
        border: tints2[dark ? 800 : 300].hex,
        focusRing: import_color.hues.blue[500].hex,
        shadow: {
          outline: (0, import_color_fns.rgba)(tints2[500].hex, dark ? 0.2 : 0.4),
          umbra: (0, import_color_fns.rgba)(dark ? import_color.black.hex : tints2[500].hex, 0.2),
          penumbra: (0, import_color_fns.rgba)(dark ? import_color.black.hex : tints2[500].hex, 0.14),
          ambient: (0, import_color_fns.rgba)(dark ? import_color.black.hex : tints2[500].hex, 0.12)
        }
      };
    }
    const tints = tones[name] || tones.default;
    return {
      fg: tints[dark ? 100 : 900].hex,
      bg: tints[dark ? 950 : 50].hex,
      border: tints[dark ? 800 : 200].hex,
      focusRing: tints[500].hex,
      shadow: {
        outline: (0, import_color_fns.rgba)(tints[500].hex, dark ? 0.2 : 0.4),
        umbra: (0, import_color_fns.rgba)(dark ? import_color.black.hex : tints[500].hex, 0.2),
        penumbra: (0, import_color_fns.rgba)(dark ? import_color.black.hex : tints[500].hex, 0.14),
        ambient: (0, import_color_fns.rgba)(dark ? import_color.black.hex : tints[500].hex, 0.12)
      }
    };
  },
  solid: ({base, dark, state, tone}) => {
    const mix = dark ? import_helpers.screen : import_helpers.multiply;
    const tints = tones[tone] || tones.default;
    if (state === "disabled") {
      return {
        bg: mix(base.bg, import_color.hues.gray[dark ? 800 : 200].hex),
        border: mix(base.bg, import_color.hues.gray[dark ? 800 : 200].hex),
        fg: mix(base.bg, dark ? import_color.black.hex : import_color.white.hex)
      };
    }
    if (state === "hovered") {
      return {
        bg: mix(base.bg, tints[dark ? 300 : 600].hex),
        border: mix(base.bg, tints[dark ? 300 : 600].hex),
        fg: mix(base.bg, dark ? import_color.black.hex : import_color.white.hex)
      };
    }
    if (state === "pressed") {
      return {
        bg: mix(base.bg, tints[dark ? 200 : 800].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? import_color.black.hex : import_color.white.hex)
      };
    }
    if (state === "selected") {
      return {
        bg: mix(base.bg, tints[dark ? 200 : 800].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? import_color.black.hex : import_color.white.hex)
      };
    }
    return {
      bg: mix(base.bg, tints[dark ? 400 : 500].hex),
      border: mix(base.bg, tints[dark ? 400 : 500].hex),
      fg: mix(base.bg, dark ? import_color.black.hex : import_color.white.hex)
    };
  },
  muted: ({base, dark, state, tone}) => {
    const mix = dark ? import_helpers.screen : import_helpers.multiply;
    const tints = tones[tone] || tones.default;
    if (state === "disabled") {
      return {
        bg: mix(base.bg, import_color.hues.gray[dark ? 950 : 50].hex),
        border: mix(base.bg, import_color.hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, import_color.hues.gray[dark ? 800 : 200].hex)
      };
    }
    if (state === "hovered") {
      return {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        border: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 100 : 900].hex)
      };
    }
    if (state === "pressed") {
      return {
        bg: mix(base.bg, tints[dark ? 900 : 100].hex),
        border: mix(base.bg, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 100 : 900].hex)
      };
    }
    if (state === "selected") {
      return {
        bg: mix(base.bg, tints[dark ? 900 : 100].hex),
        border: mix(base.bg, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 100 : 900].hex)
      };
    }
    return {
      bg: mix(base.bg, tints[dark ? 900 : 100].hex),
      border: mix(base.bg, tints[dark ? 900 : 100].hex),
      fg: mix(base.bg, tints[dark ? 300 : 700].hex)
    };
  },
  button: ({base, mode, muted, solid}) => {
    if (mode === "bleed") {
      return __assign(__assign({}, muted), {
        enabled: __assign(__assign({}, muted.enabled), {
          bg: base.bg,
          border: base.bg
        }),
        disabled: __assign(__assign({}, muted.disabled), {
          bg: base.bg,
          border: base.bg
        })
      });
    }
    if (mode === "ghost") {
      return __assign(__assign({}, solid), {
        enabled: __assign(__assign({}, muted.enabled), {bg: base.bg, border: base.border}),
        disabled: __assign(__assign({}, muted.disabled), {
          bg: base.bg
        })
      });
    }
    return solid;
  },
  input: ({base, dark, mode, state}) => {
    const mix = dark ? import_helpers.screen : import_helpers.multiply;
    if (mode === "invalid") {
      const tints = tones.critical;
      return {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 300 : 700].hex),
        border: mix(base.bg, tints[dark ? 800 : 200].hex),
        placeholder: mix(base.bg, tints[dark ? 300 : 700].hex)
      };
    }
    if (state === "hovered") {
      return {
        bg: base.bg,
        fg: base.fg,
        border: mix(base.bg, import_color.hues.gray[dark ? 700 : 300].hex),
        placeholder: mix(base.bg, import_color.hues.gray[dark ? 300 : 700].hex)
      };
    }
    if (state === "disabled") {
      return {
        bg: mix(base.bg, import_color.hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, import_color.hues.gray[dark ? 800 : 200].hex),
        border: mix(base.bg, import_color.hues.gray[dark ? 900 : 100].hex),
        placeholder: mix(base.bg, import_color.hues.gray[dark ? 900 : 100].hex)
      };
    }
    return {
      bg: base.bg,
      fg: base.fg,
      border: base.border,
      placeholder: mix(base.bg, import_color.hues.gray[dark ? 300 : 700].hex)
    };
  },
  card: ({base, dark, muted, name, state}) => {
    let mix = dark ? import_helpers.screen : import_helpers.multiply;
    if (state === "selected") {
      mix = dark ? import_helpers.multiply : import_helpers.screen;
      const tint = ["default", "transparent"].includes(name) ? import_color.hues.blue : tones[name];
      const bg = tint[dark ? 400 : 500].hex;
      return {
        bg,
        fg: dark ? import_color.black.hex : import_color.white.hex,
        border: tint[dark ? 300 : 400].hex,
        muted: {
          fg: mix(bg, import_color.hues.gray[dark ? 600 : 300].hex)
        },
        accent: {
          fg: mix(bg, import_color.hues.red[dark ? 600 : 500].hex)
        },
        link: {
          fg: mix(bg, import_color.hues.blue[dark ? 600 : 300].hex)
        },
        code: {
          bg: mix(bg, import_color.hues.gray[dark ? 50 : 950].hex),
          fg: mix(bg, import_color.hues.gray[dark ? 600 : 300].hex)
        }
      };
    }
    if (state === "hovered") {
      const bg = muted.hovered.bg;
      return __assign(__assign({}, muted.hovered), {
        border: mix(bg, base.border),
        muted: {
          fg: mix(bg, import_color.hues.gray[dark ? 400 : 700].hex)
        },
        accent: {
          fg: mix(bg, import_color.hues.red[dark ? 500 : 500].hex)
        },
        link: {
          fg: mix(bg, import_color.hues.blue[dark ? 400 : 700].hex)
        },
        code: {
          bg: mix(bg, import_color.hues.gray[dark ? 950 : 50].hex),
          fg: import_color.hues.gray[dark ? 400 : 600].hex
        }
      });
    }
    if (state === "pressed") {
      return __assign(__assign({}, muted.pressed), {
        fg: base.fg,
        muted: {
          fg: mix(muted.pressed.bg, import_color.hues.gray[dark ? 400 : 700].hex)
        },
        accent: {
          fg: mix(muted.pressed.bg, import_color.hues.red[dark ? 500 : 500].hex)
        },
        link: {
          fg: mix(muted.pressed.bg, import_color.hues.blue[dark ? 400 : 700].hex)
        },
        code: {
          bg: mix(muted.pressed.bg, import_color.hues.gray[dark ? 950 : 50].hex),
          fg: import_color.hues.gray[dark ? 400 : 700].hex
        }
      });
    }
    if (state === "disabled") {
      return __assign(__assign({}, muted.disabled), {
        muted: {
          fg: muted.disabled.fg
        },
        accent: {
          fg: muted.disabled.fg
        },
        link: {
          fg: muted.disabled.fg
        },
        code: {
          bg: "transparent",
          fg: muted.disabled.fg
        }
      });
    }
    return {
      bg: base.bg,
      fg: base.fg,
      border: base.border,
      muted: {
        fg: mix(base.bg, import_color.hues.gray[dark ? 400 : 700].hex)
      },
      accent: {
        fg: mix(base.bg, import_color.hues.red[dark ? 500 : 500].hex)
      },
      link: {
        fg: mix(base.bg, import_color.hues.blue[dark ? 400 : 700].hex)
      },
      code: {
        bg: mix(base.bg, import_color.hues.gray[dark ? 950 : 50].hex),
        fg: import_color.hues.gray[dark ? 400 : 700].hex
      }
    };
  },
  spot: ({base, dark, key}) => {
    const mix = dark ? import_helpers.screen : import_helpers.multiply;
    return mix(base.bg, import_color.hues[key][dark ? 400 : 500].hex);
  },
  syntax: ({base, dark}) => {
    const mix = dark ? import_helpers.screen : import_helpers.multiply;
    const mainShade = dark ? 400 : 600;
    const secondaryShade = dark ? 600 : 400;
    return {
      atrule: mix(base.bg, import_color.hues.purple[mainShade].hex),
      attrName: mix(base.bg, import_color.hues.green[mainShade].hex),
      attrValue: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      attribute: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      boolean: mix(base.bg, import_color.hues.purple[mainShade].hex),
      builtin: mix(base.bg, import_color.hues.purple[mainShade].hex),
      cdata: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      char: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      class: mix(base.bg, import_color.hues.orange[mainShade].hex),
      className: mix(base.bg, import_color.hues.cyan[mainShade].hex),
      comment: mix(base.bg, import_color.hues.gray[secondaryShade].hex),
      constant: mix(base.bg, import_color.hues.purple[mainShade].hex),
      deleted: mix(base.bg, import_color.hues.red[mainShade].hex),
      doctype: mix(base.bg, import_color.hues.gray[secondaryShade].hex),
      entity: mix(base.bg, import_color.hues.red[mainShade].hex),
      function: mix(base.bg, import_color.hues.green[mainShade].hex),
      hexcode: mix(base.bg, import_color.hues.blue[mainShade].hex),
      id: mix(base.bg, import_color.hues.purple[mainShade].hex),
      important: mix(base.bg, import_color.hues.purple[mainShade].hex),
      inserted: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      keyword: mix(base.bg, import_color.hues.magenta[mainShade].hex),
      number: mix(base.bg, import_color.hues.purple[mainShade].hex),
      operator: mix(base.bg, import_color.hues.magenta[mainShade].hex),
      prolog: mix(base.bg, import_color.hues.gray[secondaryShade].hex),
      property: mix(base.bg, import_color.hues.blue[mainShade].hex),
      pseudoClass: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      pseudoElement: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      punctuation: mix(base.bg, import_color.hues.gray[mainShade].hex),
      regex: mix(base.bg, import_color.hues.blue[mainShade].hex),
      selector: mix(base.bg, import_color.hues.red[mainShade].hex),
      string: mix(base.bg, import_color.hues.yellow[mainShade].hex),
      symbol: mix(base.bg, import_color.hues.purple[mainShade].hex),
      tag: mix(base.bg, import_color.hues.red[mainShade].hex),
      unit: mix(base.bg, import_color.hues.orange[mainShade].hex),
      url: mix(base.bg, import_color.hues.red[mainShade].hex),
      variable: mix(base.bg, import_color.hues.red[mainShade].hex)
    };
  }
});
